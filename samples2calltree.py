#!/usr/bin/python

import sys
import os
import time

from sample_reader import parseFile
import syscalls


outFd = None
allThreads = None
numThreads = None

def handleHeader (header):
    global allThreads, numThreads
    allThreads = header['all_threads']
    numThreads = len(allThreads)

    outFd.write("pid: %d\n" % allThreads[0]) # assume that first thread ID is PID of whole process
    outFd.write("events: NumSamples")
    if len(allThreads) > 1:
        threadListStr = " ".join( [ "thread_%d" % t for t in allThreads ] )
        outFd.write(" " + threadListStr)
    outFd.write("\n\n")

def handleEvent (e):
    threadId = e[2]
    if numThreads > 1:
        # hack to work around https://bugs.kde.org/show_bug.cgi?id=263594:
        # (Kcachegrind chokes if a call has an inclusive cost of zero for some event types)
        costZero = 1
        costOne = 1000

        threadCost = [costZero] * numThreads
        threadIndex = allThreads.index(threadId)
        threadCost[threadIndex] = costOne
        threadCostStr = " " + (" ".join( [ str(x) for x in threadCost ] ))
    else:
        costZero = 0
        costOne = 1
        threadCostStr = ""

    outFd.write("# event at %s (PID: %d)\n" % ( time.strftime('%c', time.localtime(e[0]) ), threadId) )

    frames = []
    knownFunctions = {}
    regs = e[3]

    currFrame = 1
    for f in e[1]:
        binName = f[1]
        if binName is None: binName = '???'
        funcName = f[2]
        if funcName is None:
            if f[1] == '[vdso]':
                funcName = '_vdso_'
                if currFrame == 1 and regs.has_key('oeax'):
                    # resolve syscall number which was stored in ORIG_EAX:
                    syscallId = regs['oeax']
                    if syscalls.SYSCALL_TABLE.has_key(syscallId):
                        funcName = 'SYS_%s' % syscalls.SYSCALL_TABLE[syscallId]
                    else:
                        funcName = 'SYS_%d' % syscallId
            else:
                funcName = '_0x%08x' % f[0]
                if f[1] is not None:
                    funcName += "_" + os.path.basename(f[1])
        lineNo = f[4]
        if lineNo is None: lineNo = 0
        fileName = f[3]
        if fileName is None: fileName = '???'
        # TODO: try to fix address (it currently usually points to _next_ instruction)
        localAddr = f[5]
        if localAddr is None: localAddr = 0

        # simple cycle detection
        if not(knownFunctions.has_key(funcName)):
            knownFunctions[funcName] = 1
        else:
            knownFunctions[funcName] += 1

        if knownFunctions[funcName] > 1:
            funcName += "'%d" % knownFunctions[funcName]

        # (address, binary file, function, source file, line number, address in binary file)
        frames.append( (f[0], binName, funcName, fileName, lineNo, localAddr) )

        if currFrame == 1:
            outFd.write("ob=%s\n" % binName)
            outFd.write("fl=%s\n" % fileName)
            outFd.write("fn=%s\n" % funcName)
            outFd.write("0x%x %d %d%s\n" % (localAddr, lineNo, costOne, threadCostStr))
        currFrame += 1

    # function calls
    outFd.write("# function calls\n")
    currFrame = 1
    for f in frames[1:]:
        if f[2] is not None:
            prevFrame = frames[ currFrame-1 ]
            
            if prevFrame[2] is not None:
                lineNo = f[4]
                prevLineNo = prevFrame[4]

                outFd.write("ob=%s\n" % f[1])
                outFd.write("fl=%s\n" % f[3])
                outFd.write("fn=%s\n" % f[2])
                outFd.write("cob=%s\n" % prevFrame[1])
                outFd.write("cfl=%s\n" % prevFrame[3])
                outFd.write("cfn=%s\n" % prevFrame[2])
                outFd.write("calls=%d 0x%x %d\n" % (costOne, prevFrame[5], prevLineNo))
                outFd.write("0x%x %d %d%s\n" % (f[5], lineNo, costOne, threadCostStr))
        currFrame += 1

    outFd.write("\n")

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print "Usage: %s <sample data file>" % sys.argv[0]
        sys.exit(1)

    sampleFile = sys.argv[1]

    outFd = open("calltree.%s" % os.path.basename(sampleFile), "w")

    outFd.write("version: 1\n")
    outFd.write("creator: %s\n" % sys.argv[0])

    outFd.write("# callgrind output file, generated by '%s'\n" % sys.argv)
    outFd.write("positions: instr line\n")

    parseFile(sampleFile, handleEvent, handleHeader)

